<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Core Defense</title>
    <style>
        /* Modern Reset & Base Styles */
        * {
            box-sizing: border-box;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #fff;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        /* Canvas Container */
        #game-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            overflow: hidden;
            cursor: crosshair;
            background: radial-gradient(circle at 10% 50%, #1a1a2e 0%, #000000 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay - HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
        }

        .stat-group {
            display: flex;
            gap: 10px;
        }

        .stat-box {
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(8px);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .stat-value { font-size: 1.3rem; font-weight: 800; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .stat-label { font-size: 0.65rem; color: #8899aa; text-transform: uppercase; letter-spacing: 1.5px; margin-top: 2px; }

        .currency-bits { color: #00ffff; text-shadow: 0 0 15px rgba(0,255,255,0.6); }
        
        /* HP Bar specific styling */
        .hp-container {
            flex-grow: 1;
            max-width: 400px;
            margin: 0 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            opacity: 0.9;
        }
        
        .hp-bar-bg {
            width: 100%;
            height: 8px;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 5px #000;
        }
        
        .hp-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ffcc00, #00ffaa);
            background-size: 200% 100%;
            animation: gradientMove 3s linear infinite;
            transition: width 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            box-shadow: 0 0 15px rgba(0,255,170,0.4);
        }

        @keyframes gradientMove { 0% { background-position: 100% 0; } 100% { background-position: 0 0; } }

        .hp-text {
            text-align: center;
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 6px;
            letter-spacing: 2px;
            font-weight: 600;
        }

        /* Upgrade Panel */
        #upgrade-panel {
            height: 25vh;
            min-height: 190px;
            max-height: 280px;
            background: rgba(10, 10, 12, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            z-index: 20;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.8);
        }

        .panel-header {
            padding: 10px 20px;
            background: rgba(255,255,255,0.03);
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.85rem;
            color: #8899aa;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 45px;
        }

        #prestige-area { display: flex; align-items: center; gap: 15px; }

        #prestige-btn {
            background: linear-gradient(135deg, #7000ff, #ff0055);
            border: none;
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            display: none;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.4);
            animation: pulseBtn 2s infinite;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        @keyframes pulseBtn { 0% { transform: scale(1); } 50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 0, 85, 0.6); } 100% { transform: scale(1); } }

        .upgrades-container {
            flex-grow: 1;
            display: flex;
            gap: 12px;
            padding: 15px 20px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            align-items: center;
        }

        .upgrades-container::-webkit-scrollbar { height: 4px; }
        .upgrades-container::-webkit-scrollbar-track { background: transparent; }
        .upgrades-container::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

        .card {
            flex: 0 0 auto;
            width: 125px;
            height: 100%;
            background: linear-gradient(145deg, #1a1a20, #121215);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .card:hover { transform: translateY(-5px); border-color: rgba(255,255,255,0.2); box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .card:active { transform: scale(0.96); }
        
        .card.disabled { 
            opacity: 0.5; 
            filter: grayscale(0.9); 
            cursor: default; 
            transform: none !important; 
            box-shadow: none;
        }

        .card-icon { 
            font-size: 1.6rem; 
            text-align: center; 
            margin-top: 5px; 
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.2));
        }
        
        .card-details { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .card-title { font-size: 0.75rem; font-weight: 700; color: #fff; text-align: center; line-height: 1.2; }
        .card-stat { font-size: 0.65rem; color: #8899aa; text-align: center; font-weight: 500; }
        
        .card-cost {
            font-size: 0.8rem;
            font-weight: 700;
            color: #00ffff;
            text-align: center;
            background: rgba(0, 255, 255, 0.05);
            padding: 6px;
            border-radius: 6px;
            margin-top: 6px;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        .lvl-badge {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 0.6rem;
            background: rgba(255,255,255,0.1);
            color: #aaa;
            padding: 2px 8px;
            border-bottom-left-radius: 8px;
            font-weight: 600;
        }

        /* Modal */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(12px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal {
            background: rgba(20, 20, 25, 0.95);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-radius: 16px;
            padding: 40px;
            max-width: 450px;
            width: 85%;
            text-align: center;
            box-shadow: 0 0 80px rgba(255, 0, 50, 0.2);
            position: relative;
        }
        
        .modal::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ff0055, transparent);
        }

        .modal h2 { margin: 0 0 10px 0; color: #fff; font-size: 2.2rem; letter-spacing: 2px; text-transform: uppercase; font-weight: 900; }
        .modal p { color: #aaa; margin-bottom: 30px; line-height: 1.6; font-size: 1.1rem; }
        
        .btn-primary {
            background: #fff;
            color: #000;
            border: none;
            padding: 14px 35px;
            font-size: 1rem;
            font-weight: 800;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(255,255,255,0.4);
        }
        .btn-primary:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(255,255,255,0.6); }

        /* Notification */
        #notification-area {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 50;
            align-items: center;
        }
        
        .notification {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            color: #fff;
            padding: 12px 24px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            animation: notifSlide 2s forwards cubic-bezier(0.19, 1, 0.22, 1);
            white-space: nowrap;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        @keyframes notifSlide {
            0% { opacity: 0; transform: translateY(30px) scale(0.9); }
            15% { opacity: 1; transform: translateY(0) scale(1); }
            85% { opacity: 1; transform: translateY(-10px); }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        @media (max-width: 600px) {
            .stat-box { padding: 6px 10px; min-width: 60px; }
            .stat-value { font-size: 1.1rem; }
            .stat-label { font-size: 0.55rem; }
            .card { width: 105px; padding: 8px; }
            .card-title { font-size: 0.65rem; }
            .card-icon { font-size: 1.3rem; }
            #hud { padding: 10px; }
        }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">
        <div class="stat-group">
            <div class="stat-box">
                <span class="stat-value" id="level-display">1</span>
                <span class="stat-label">Wave</span>
            </div>
        </div>
        
        <div class="hp-container">
             <div class="hp-bar-bg">
                <div id="core-hp-bar" class="hp-bar-fill"></div>
             </div>
             <div class="hp-text">CORE INTEGRITY</div>
        </div>

        <div class="stat-group">
            <div class="stat-box">
                <span class="stat-value currency-bits" id="money-display">0</span>
                <span class="stat-label">Bits</span>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="notification-area"></div>
    </div>

    <!-- Upgrade Panel -->
    <div id="upgrade-panel">
        <div class="panel-header">
            <span>Systems Upgrade</span>
            <div id="prestige-area">
                <span id="prestige-currency-display" style="display:none; color: #ff0055; font-weight:800; font-size: 0.9rem; text-shadow: 0 0 10px rgba(255,0,85,0.4);">0 BYTES</span>
                <button id="prestige-btn">Reboot</button>
            </div>
        </div>
        <div class="upgrades-container" id="cards-container">
            <!-- Cards generated by JS -->
        </div>
    </div>

    <!-- Modal -->
    <div id="modal-overlay">
        <div class="modal" id="modal-content">
            <h2 id="modal-title">CRITICAL FAILURE</h2>
            <p id="modal-msg">Core Integrity Lost.</p>
            <button class="btn-primary" id="modal-btn">Initialize Reboot</button>
        </div>
    </div>

<script>
/**
 * GAME CONFIGURATION & STATE
 */
const state = {
    money: 0,
    level: 1,
    coreHp: 100,
    maxCoreHp: 100,
    prestigeCurrency: 0,
    gameOver: false,
    lastTime: 0,
    spawnTimer: 0,
    spawnRate: 1500,
    isPlaying: true,
    enemiesKilled: 0
};

// 1 Byte = +25% Global Damage
const getPrestigeMult = () => 1 + (state.prestigeCurrency * 0.25);

const upgrades = [
    {
        id: 'clickDmg',
        name: 'Pulse Cannon',
        icon: 'ðŸ–±ï¸',
        baseCost: 15,
        costMult: 1.5,
        count: 0,
        getVal: (n) => 3 + (n * 4), // Buffed base damage slightly
        desc: (v) => `Dmg: ${format(v * getPrestigeMult())}`
    },
    {
        id: 'autoDmg',
        name: 'Auto-Turret',
        icon: 'ðŸ’ ',
        baseCost: 20, // Reduced from 30
        costMult: 1.35, // Reduced from 1.4 for better scaling
        count: 0,
        getVal: (n) => n === 0 ? 0 : 8 + (n * 5), // Buffed significantly (was 5 + n*4)
        desc: (v) => `Dmg: ${format(v * getPrestigeMult())}`
    },
    {
        id: 'autoSpeed',
        name: 'Cyclic Rate',
        icon: 'âš¡',
        baseCost: 100, // Reduced from 150
        costMult: 1.8,
        count: 0,
        max: 25,
        getVal: (n) => Math.max(200, 2000 - (n * 72)),
        desc: (v) => `RPM: ${(60000/v).toFixed(0)}`
    },
    {
        id: 'multishot',
        name: 'Split-Fire',
        icon: 'ðŸ“¶',
        baseCost: 600,
        costMult: 2.5,
        count: 0,
        max: 8,
        getVal: (n) => 1 + n, 
        desc: (v) => `Targets: ${v}`
    },
    {
        id: 'explosive',
        name: 'Nova Round',
        icon: 'ðŸ’¥',
        baseCost: 1200,
        costMult: 2.2,
        count: 0,
        max: 15,
        getVal: (n) => n * 30, 
        desc: (v) => `Radius: ${v}px`
    },
    {
        id: 'critChance',
        name: 'Crit Logic',
        icon: 'ðŸŽ¯',
        baseCost: 500,
        costMult: 1.6,
        count: 0,
        max: 50,
        getVal: (n) => n * 2,
        desc: (v) => `Crit: ${v}%`
    },
    {
        id: 'economy',
        name: 'Data Mining',
        icon: 'ðŸ’Ž',
        baseCost: 250, // Reduced from 300
        costMult: 1.45, // Reduced from 1.5
        count: 0,
        getVal: (n) => 1 + (n * 0.25), 
        desc: (v) => `Yield: x${v.toFixed(2)}`
    },
    {
        id: 'regen',
        name: 'Nanobots',
        icon: 'ðŸ©¹',
        baseCost: 1000,
        costMult: 2.0,
        count: 0,
        getVal: (n) => n * 2.0,
        desc: (v) => `Repair: ${v}/s`
    }
];

function format(num) {
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'k';
    return Math.floor(num);
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;
let spawnDistance = 800; 

function resize() {
    width = canvas.width = document.getElementById('game-container').offsetWidth;
    height = canvas.height = document.getElementById('game-container').offsetHeight;
    spawnDistance = Math.min(width, 1000);
}
window.addEventListener('resize', resize);
resize();

/**
 * VISUAL ENTITIES
 */
class Star {
    constructor() {
        this.reset();
        this.x = Math.random() * width; // Random start pos
    }
    reset() {
        this.x = width;
        this.y = Math.random() * height;
        this.z = Math.random() * 2 + 0.5; // Depth
        this.size = Math.random() * 1.5;
        this.alpha = Math.random() * 0.5 + 0.1;
    }
    update(dt) {
        this.x -= (this.z * 0.5) * (dt/16); // Parallax speed
        if (this.x < 0) this.reset();
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
    }
}

class Shockwave {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 5;
        this.maxRadius = 50;
        this.alpha = 1;
        this.life = 0.5; // seconds
    }
    update(dt) {
        this.radius += 100 * (dt/1000); // Expand speed
        this.life -= dt/1000;
        this.alpha = Math.max(0, this.life / 0.5);
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx) {
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.color;
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, type = 'spark') {
        this.x = x;
        this.y = y;
        this.color = color;
        this.type = type;
        
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1; // Faster particles
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.size = Math.random() * 3 + 1;
    }

    update(dt) {
        this.x += this.vx * (dt/16);
        this.y += this.vy * (dt/16);
        
        // Friction
        this.vx *= 0.95;
        this.vy *= 0.95;
        
        this.size *= 0.95; // Shrink
        this.life -= this.decay;
        if (this.life <= 0 || this.size < 0.1) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.globalCompositeOperation = 'lighter'; // Glowy
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
    }
}

/**
 * GAME ENTITIES
 */
class Entity {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.markedForDeletion = false;
    }
}

class Enemy extends Entity {
    constructor(lvl) {
        super(spawnDistance + 40 + Math.random()*50, Math.random() * (height - 80) + 40, '');
        
        // Smoother scaling for late game (1.15 down from 1.18)
        const hpScale = Math.pow(1.15, lvl - 1); 
        this.maxHp = Math.floor(10 * hpScale);
        this.hp = this.maxHp;
        
        this.baseSpeed = Math.random() * 0.4 + 0.6 + (lvl * 0.015);
        this.speed = this.baseSpeed;
        this.size = 22;
        this.scale = 0; // Spawn animation
        this.hitFlash = 0; // Flash frame
        this.frozen = 0;
        
        // --- Enemy Types ---
        const rand = Math.random();
        this.type = 'basic';
        this.color = '#ff0055'; // Pink/Red
        this.bits = Math.floor(lvl * 1.5);
        this.armor = 0;
        this.alpha = 1; // Opacity for phantoms

        // Armored (Orange)
        if (rand < 0.15 && lvl >= 4) {
            this.type = 'armored';
            this.maxHp *= 2.5;
            this.hp = this.maxHp;
            this.speed *= 0.7;
            this.size = 28;
            this.color = '#ffaa00';
            this.bits *= 2;
            this.armor = lvl * 0.5;
        } 
        // Healer (Green)
        else if (rand < 0.25 && rand > 0.15 && lvl >= 7) {
            this.type = 'healer';
            this.maxHp *= 1.2;
            this.hp = this.maxHp;
            this.speed *= 0.9;
            this.color = '#00ffaa';
            this.size = 24;
            this.healTimer = 0;
            this.bits *= 3;
        }
        // Dasher (White)
        else if (rand < 0.35 && rand > 0.25 && lvl >= 10) {
            this.type = 'dasher';
            this.maxHp *= 0.6;
            this.hp = this.maxHp;
            this.speed *= 1.2;
            this.color = '#ffffff';
            this.size = 18;
            this.dashTimer = Math.random() * 2000;
            this.bits *= 2;
        }
        // Phase Shifter (Purple/Transparent) - Wave 45+
        else if (rand < 0.45 && rand > 0.35 && lvl >= 45) {
            this.type = 'shifter';
            this.maxHp *= 0.8;
            this.hp = this.maxHp;
            this.speed *= 1.4;
            this.color = '#aa00ff';
            this.size = 20;
            this.phaseTimer = 0;
            this.bits *= 4;
        }
        // Juggernaut (Big Dark Red) - Wave 75+
        else if (rand < 0.55 && rand > 0.45 && lvl >= 75) {
            this.type = 'juggernaut';
            this.maxHp *= 6.0;
            this.hp = this.maxHp;
            this.speed *= 0.4;
            this.color = '#550000';
            this.size = 40;
            this.armor = lvl * 1.0; // High armor
            this.bits *= 8;
        }
        // Banshee (Cyan Sine Wave) - Wave 100+
        else if (rand < 0.65 && rand > 0.55 && lvl >= 100) {
            this.type = 'banshee';
            this.maxHp *= 1.0;
            this.hp = this.maxHp;
            this.speed *= 1.8;
            this.color = '#00ffff';
            this.size = 18;
            this.startY = this.y;
            this.timeOffset = Math.random() * 100;
            this.bits *= 5;
        }

        // Boss Logic
        if (lvl % 10 === 0 && !enemies.some(e => e.isBoss)) {
            this.isBoss = true;
            this.maxHp *= 15;
            this.hp = this.maxHp;
            this.size = 70;
            this.speed = 0.25;
            this.color = '#aa00ff'; // Purple
            this.bits *= 50;
            this.type = 'boss';
        }

        const ecoMult = upgrades.find(u => u.id === 'economy');
        this.bits = Math.max(1, Math.floor(this.bits * ecoMult.getVal(ecoMult.count)));
    }

    update(dt) {
        // Spawn Scale In
        if (this.scale < 1) this.scale = Math.min(1, this.scale + dt/300);

        if (this.frozen > 0) this.frozen -= dt;

        // Behavior
        if (this.type === 'dasher' && !this.frozen) {
            this.dashTimer -= dt;
            if (this.dashTimer <= 0) {
                this.x -= 100; // Bigger Dash
                this.dashTimer = 2000 + Math.random() * 1000;
                createParticles(this.x + 50, this.y, '#fff', 5);
            }
        }
        else if (this.type === 'healer') {
            this.healTimer = (this.healTimer || 0) + dt;
            if (this.healTimer > 1500) {
                this.healNearby();
                this.healTimer = 0;
            }
        }
        else if (this.type === 'shifter') {
            this.phaseTimer = (this.phaseTimer || 0) + dt;
            // Oscillate opacity
            this.alpha = 0.3 + 0.7 * Math.abs(Math.sin(this.phaseTimer / 500));
        }
        else if (this.type === 'banshee' && !this.frozen) {
            // Sine wave movement
            const time = Date.now() / 300 + this.timeOffset;
            this.y = this.startY + Math.sin(time) * 60;
            // Keep bounds
            if (this.y < 30) this.y = 30;
            if (this.y > height - 30) this.y = height - 30;
        }

        const currentSpeed = this.frozen > 0 ? 0 : this.speed;
        this.x -= currentSpeed * (dt / 16);
        
        if (this.x < 60) {
            takeDamage(this.hp); 
            this.markedForDeletion = true;
            createExplosion(this.x, this.y, 20, this.color);
        }
    }

    healNearby() {
        // Visual Heal Pulse
        shockwaves.push(new Shockwave(this.x, this.y, '#00ffaa'));
        enemies.forEach(e => {
            if (e !== this && !e.markedForDeletion) {
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < 180) {
                    e.hp = Math.min(e.maxHp, e.hp + (this.maxHp * 0.1));
                    floaters.push(new FloatingText(e.x, e.y - 15, '+', '#00ffaa'));
                }
            }
        });
    }

    draw(ctx) {
        ctx.save();
        // Scale Animation
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        
        // Transparency for Shifters
        ctx.globalAlpha = this.alpha;

        // Hit Flash
        if (this.hitFlash > 0) {
            ctx.fillStyle = '#ffffff';
            this.hitFlash--;
        } else {
            ctx.fillStyle = this.color;
        }

        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        
        ctx.beginPath();
        if (this.isBoss) {
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const r = i % 2 === 0 ? this.size : this.size * 0.6;
                ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
        } else if (this.type === 'armored') {
            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(-this.size/2 + 4, -this.size/2 + 4, this.size - 8, this.size - 8);
        } else if (this.type === 'healer') {
            const s = this.size;
            ctx.rect(-s/3, -s, s/1.5, s*2);
            ctx.rect(-s, -s/3, s*2, s/1.5);
        } else if (this.type === 'dasher') {
            ctx.moveTo(-this.size, -this.size/2);
            ctx.lineTo(this.size, 0);
            ctx.lineTo(-this.size, this.size/2);
        } else if (this.type === 'shifter') {
            // Diamond shape
            ctx.moveTo(0, -this.size);
            ctx.lineTo(this.size, 0);
            ctx.lineTo(0, this.size);
            ctx.lineTo(-this.size, 0);
        } else if (this.type === 'juggernaut') {
            // Octagonish/Blocky
            const s = this.size;
            ctx.rect(-s/2, -s/2, s, s);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 4;
            ctx.strokeRect(-s/2, -s/2, s, s);
        } else if (this.type === 'banshee') {
            // Wave shape or crescent
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.stroke();
            ctx.lineWidth = 1;
        } else {
            // Pulse Effect for basic enemies
            const pulse = 1 + Math.sin(Date.now() / 200) * 0.05;
            ctx.scale(pulse, pulse);
            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
        }
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // HP Bar
        if (this.hp < this.maxHp) {
            ctx.translate(-this.x, -this.y); // Reset transform for static HP bar
            const pct = Math.max(0, this.hp / this.maxHp);
            const w = 36;
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(this.x - w/2, this.y - this.size - 15, w, 5);
            ctx.fillStyle = pct < 0.3 ? '#ff0000' : '#00ffaa';
            ctx.fillRect(this.x - w/2, this.y - this.size - 15, w * pct, 5);
        }
        
        ctx.restore();
    }
}

class Projectile extends Entity {
    constructor(target, isAuto) {
        super(40, height / 2, '#00ffff');
        this.target = target;
        this.speed = 22; 
        this.size = 5;
        this.isAuto = isAuto;
        
        const bombU = upgrades.find(u => u.id === 'explosive');
        this.blastRadius = bombU.getVal(bombU.count);
        
        // Spawn slightly offset from core center for realism
        this.y += (Math.random() - 0.5) * 8; 
    }

    update(dt) {
        if (this.target.markedForDeletion) {
            this.markedForDeletion = true;
            // Create a small poof if target dies mid-flight
            createParticles(this.x, this.y, '#00ffff', 2);
            return;
        }

        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < this.speed * (dt/10)) {
            this.hit();
        } else {
            this.x += (dx / dist) * this.speed * (dt/16);
            this.y += (dy / dist) * this.speed * (dt/16);
        }
        
        // Trail
        particles.push(new Particle(this.x, this.y, this.blastRadius > 0 ? '#ffaa00' : '#00ffff'));
    }
    
    hit() {
        const dmgInfo = getDamage(this.isAuto ? 'auto' : 'click');
        hitEnemy(this.target, dmgInfo);
        this.markedForDeletion = true;

        if (this.blastRadius > 0) {
            createExplosion(this.x, this.y, this.blastRadius, '#ffaa00');
            shockwaves.push(new Shockwave(this.x, this.y, '#ffaa00'));
            enemies.forEach(e => {
                if (e === this.target || e.markedForDeletion) return;
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < this.blastRadius + e.size) {
                    const aoeDmg = { damage: dmgInfo.damage * 0.5, isCrit: false };
                    hitEnemy(e, aoeDmg);
                }
            });
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.blastRadius > 0 ? '#ffaa00' : '#00ffff';
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowBlur = 10;
        ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalCompositeOperation = 'source-over';
    }
}

class FloatingText {
    constructor(x, y, text, color, size = 18) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.size = size;
        this.life = 1.0;
        this.vy = -3; // Initial pop up speed
        this.scale = 0;
    }

    update(dt) {
        this.y += this.vy * (dt/16);
        this.vy *= 0.95; // Gravityish friction
        
        if (this.scale < 1) this.scale += 0.2; // Pop in
        
        this.life -= 0.02 * (dt/16);
        if (this.life <= 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = Math.max(0, this.life);
        
        ctx.fillStyle = this.color;
        ctx.font = `900 ${this.size}px 'Arial', sans-serif`;
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 4;
        ctx.fillText(this.text, 0, 0);
        
        // Stroke for readability
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 2;
        ctx.strokeText(this.text, 0, 0);
        
        ctx.restore();
    }
}

/**
 * GAME ENGINE
 */
let enemies = [];
let projectiles = [];
let particles = [];
let floaters = [];
let stars = [];
let shockwaves = [];

let autoFireTimer = 0;
let shakeAmount = 0;
let regenTimer = 0;
let coreRecoil = 0;
let coreAngle = 0; // For rotating shield
let closestEnemy = null; // For turret tracking

// Init Background
for(let i=0; i<60; i++) stars.push(new Star());

function update(dt) {
    if (state.gameOver) return;

    // Background
    stars.forEach(s => s.update(dt));

    // Spawner
    state.spawnTimer -= dt;
    if (state.spawnTimer <= 0) {
        enemies.push(new Enemy(state.level));
        const rate = Math.max(250, state.spawnRate - (state.level * 18));
        state.spawnTimer = rate;
    }

    // Tracking
    let minDist = Infinity;
    closestEnemy = null;
    enemies.forEach(e => {
        if(e.x < minDist) { minDist = e.x; closestEnemy = e; }
    });

    // Auto Fire
    const turretLvl = upgrades.find(u => u.id === 'autoDmg').count;
    if (turretLvl > 0) {
        const fireRate = upgrades.find(u => u.id === 'autoSpeed').getVal(upgrades.find(u => u.id === 'autoSpeed').count);
        autoFireTimer -= dt;
        
        if (autoFireTimer <= 0) {
            const multiU = upgrades.find(u => u.id === 'multishot');
            const targetCount = multiU.getVal(multiU.count);

            const sortedEnemies = [...enemies].sort((a, b) => a.x - b.x); 
            
            let shot = false;
            for(let i=0; i < Math.min(targetCount, sortedEnemies.length); i++) {
                projectiles.push(new Projectile(sortedEnemies[i], true));
                shot = true;
            }

            if (shot) {
                autoFireTimer = fireRate;
                coreRecoil = 8;
                shakeScreen(2);
            }
        }
    }

    // Regen
    const regenLvl = upgrades.find(u => u.id === 'regen').count;
    if (regenLvl > 0 && state.coreHp < state.maxCoreHp) {
        regenTimer += dt;
        if (regenTimer > 1000) {
            const amount = upgrades.find(u => u.id === 'regen').getVal(regenLvl);
            state.coreHp = Math.min(state.maxCoreHp, state.coreHp + amount);
            updateHpBar();
            regenTimer = 0;
        }
    }

    // Core Animation
    if (coreRecoil > 0) coreRecoil -= dt * 0.1;
    coreAngle += dt * 0.001;

    // Entities
    [enemies, projectiles, particles, floaters, shockwaves].forEach(arr => {
        arr.forEach(e => e.update(dt));
    });

    // Cleanup
    enemies = enemies.filter(e => !e.markedForDeletion);
    projectiles = projectiles.filter(p => !p.markedForDeletion);
    particles = particles.filter(p => !p.markedForDeletion);
    floaters = floaters.filter(f => !f.markedForDeletion);
    shockwaves = shockwaves.filter(s => !s.markedForDeletion);
}

function onKill(enemy) {
    state.money += enemy.bits;
    state.enemiesKilled++;
    updateMoney();
    
    if (state.enemiesKilled % 8 === 0) {
        state.level++;
        document.getElementById('level-display').innerText = state.level;
        
        if (state.level % 5 === 0) {
             showNotification(`âš ï¸ WAVE ${state.level} DETECTED âš ï¸`);
        } else {
             showNotification(`WAVE ${state.level}`);
        }
        
        if (state.level === 25) {
            document.getElementById('prestige-btn').style.display = 'block';
            document.getElementById('prestige-currency-display').style.display = 'block';
            showNotification("REBOOT SYSTEM ONLINE");
        }
    }
}

function draw() {
    ctx.clearRect(0,0,width,height);

    // Screen Shake
    ctx.save();
    if (shakeAmount > 0) {
        const dx = (Math.random() - 0.5) * shakeAmount;
        const dy = (Math.random() - 0.5) * shakeAmount;
        ctx.translate(dx, dy);
        shakeAmount *= 0.9;
        if (shakeAmount < 0.5) shakeAmount = 0;
    }

    // Draw Background Stars
    stars.forEach(s => s.draw(ctx));

    // Core Drawing
    const coreX = 50 - Math.max(0, coreRecoil); 
    const coreY = height / 2;
    
    // Core Shield Ring
    ctx.strokeStyle = `rgba(0, 255, 255, 0.3)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(coreX, coreY, 45, coreAngle, coreAngle + Math.PI*1.5);
    ctx.stroke();
    
    // Core Rotating Inner Ring
    ctx.strokeStyle = `rgba(0, 255, 255, 0.6)`;
    ctx.beginPath();
    ctx.arc(coreX, coreY, 35, -coreAngle*2, -coreAngle*2 + Math.PI);
    ctx.stroke();

    // Turret Barrel (Points to enemy)
    ctx.save();
    ctx.translate(coreX, coreY);
    let angle = 0;
    if (closestEnemy) {
        angle = Math.atan2(closestEnemy.y - coreY, closestEnemy.x - coreX);
    }
    ctx.rotate(angle);
    ctx.fillStyle = '#00ffff';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00ffff';
    ctx.fillRect(0, -4, 40 - coreRecoil, 8); // Barrel retracts on recoil
    ctx.restore();

    // Main Core Sphere
    ctx.shadowBlur = 40;
    ctx.shadowColor = '#00ffff';
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(coreX, coreY, 25, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner Glow
    const time = Date.now() / 300;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(coreX, coreY, 15 + Math.sin(time)*2, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Spawn Line
    if (width > spawnDistance + 50) {
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 10]);
        ctx.beginPath();
        ctx.moveTo(spawnDistance + 40, 0);
        ctx.lineTo(spawnDistance + 40, height);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Entities Layered
    shockwaves.forEach(s => s.draw(ctx));
    projectiles.forEach(p => p.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    particles.forEach(p => p.draw(ctx));
    floaters.forEach(f => f.draw(ctx));

    ctx.restore();
}

function gameLoop(timestamp) {
    const dt = timestamp - state.lastTime;
    state.lastTime = timestamp;

    if (state.isPlaying) {
        update(dt);
        draw();
    }
    
    requestAnimationFrame(gameLoop);
}

/**
 * LOGIC
 */
function getDamage(source) {
    const prestigeMult = getPrestigeMult();
    let val = 0;
    let isCrit = false;

    if (source === 'click') {
        const u = upgrades.find(x => x.id === 'clickDmg');
        val = u.getVal(u.count);
    } else {
        const u = upgrades.find(x => x.id === 'autoDmg');
        val = u.getVal(u.count);
    }

    const critU = upgrades.find(x => x.id === 'critChance');
    const chance = critU.getVal(critU.count);
    if (Math.random() * 100 < chance) {
        val *= 3; 
        isCrit = true;
    }

    val *= prestigeMult;
    return { damage: val, isCrit };
}

function hitEnemy(enemy, damageInfo) {
    let { damage, isCrit } = damageInfo;
    
    if (enemy.armor > 0) {
        damage = Math.max(1, damage - enemy.armor);
        if (damage === 1 && !isCrit) {
             createParticles(enemy.x, enemy.y, '#888', 2);
        }
    }

    enemy.hp -= damage;
    enemy.hitFlash = 3; // Flash white for 3 frames
    
    const txtColor = isCrit ? '#ff00ff' : '#fff';
    const txtSize = isCrit ? 26 : 18;
    const txt = isCrit ? 'CRIT!' : format(damage);
    floaters.push(new FloatingText(enemy.x, enemy.y - 25, txt, txtColor, txtSize));
    
    if (enemy.hp <= 0) {
        enemy.markedForDeletion = true;
        createExplosion(enemy.x, enemy.y, 10, enemy.color);
        onKill(enemy);
    }
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function createExplosion(x, y, radius, color) {
    // Lots of sparks
    for(let i=0; i<12; i++) {
        particles.push(new Particle(x, y, color));
    }
    // Shockwave
    shockwaves.push(new Shockwave(x, y, color));
    shakeScreen(4);
}

function takeDamage(amount) {
    state.coreHp -= amount;
    updateHpBar();
    shakeScreen(15);
    
    const hud = document.getElementById('game-container');
    hud.style.boxShadow = 'inset 0 0 100px rgba(255,0,0,0.4)';
    setTimeout(() => hud.style.boxShadow = 'none', 100);

    if (state.coreHp <= 0) {
        gameOver();
    }
}

function updateHpBar() {
    const pct = Math.max(0, (state.coreHp / state.maxCoreHp) * 100);
    const bar = document.getElementById('core-hp-bar');
    bar.style.width = pct + '%';
}

function updateMoney() {
    document.getElementById('money-display').innerText = format(state.money);
    renderCards();
}

function shakeScreen(amount) {
    shakeAmount = amount;
}

function showNotification(text) {
    const el = document.createElement('div');
    el.className = 'notification';
    el.innerText = text;
    document.getElementById('notification-area').appendChild(el);
    setTimeout(() => el.remove(), 2600);
}

function gameOver() {
    state.gameOver = true;
    state.isPlaying = false;
    showModal('CRITICAL FAILURE', `Wave Reached: ${state.level}`, 'REBOOT SYSTEM', () => {
        resetRun(false);
    });
}

function resetRun(isPrestige) {
    if (isPrestige) {
        const earned = Math.floor(state.level / 5);
        state.prestigeCurrency += earned;
        document.getElementById('prestige-currency-display').innerText = state.prestigeCurrency + " BYTES";
        showNotification(`REBOOT COMPLETE. +${(earned*25)}% SYS POWER.`);
    }

    state.money = 0;
    state.level = 1;
    state.coreHp = state.maxCoreHp;
    state.spawnRate = 1500;
    state.enemiesKilled = 0;
    state.spawnTimer = 0;
    state.gameOver = false;
    state.isPlaying = true;
    
    enemies = [];
    projectiles = [];
    particles = [];
    floaters = [];
    shockwaves = [];
    
    upgrades.forEach(u => u.count = 0);
    
    updateMoney();
    updateHpBar();
    document.getElementById('level-display').innerText = 1;
    renderCards();
    
    document.getElementById('modal-overlay').style.display = 'none';
    
    resize();
}

/**
 * UI & INPUT
 */
function renderCards() {
    const container = document.getElementById('cards-container');
    container.innerHTML = '';

    upgrades.forEach(u => {
        const currentCost = Math.floor(u.baseCost * Math.pow(u.costMult, u.count));
        const canAfford = state.money >= currentCost;
        const isMaxed = u.max && u.count >= u.max;

        const card = document.createElement('div');
        card.className = `card ${(!canAfford || isMaxed) ? 'disabled' : ''}`;
        
        let html = `
            <div class="lvl-badge">Lvl ${u.count}</div>
            <div class="card-icon">${u.icon}</div>
            <div class="card-details">
                <div class="card-title">${u.name}</div>
                <div class="card-stat">${u.desc(u.getVal(u.count))}</div>
            </div>
            <div class="card-cost">${isMaxed ? 'MAX' : format(currentCost)}</div>
        `;
        
        card.innerHTML = html;

        if (canAfford && !isMaxed) {
            card.onpointerdown = (e) => {
                e.preventDefault(); 
                buyUpgrade(u);
            };
        }

        container.appendChild(card);
    });
}

function buyUpgrade(u) {
    const cost = Math.floor(u.baseCost * Math.pow(u.costMult, u.count));
    if (state.money >= cost) {
        state.money -= cost;
        u.count++;
        updateMoney();
    }
}

// Input Handling
canvas.addEventListener('pointerdown', handleInput);

function handleInput(e) {
    if (state.gameOver) return;
    
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    let hit = false;
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.markedForDeletion) continue;
        
        if (clickX >= enemy.x - enemy.size - 30 && 
            clickX <= enemy.x + enemy.size + 30 &&
            clickY >= enemy.y - enemy.size - 30 &&
            clickY <= enemy.y + enemy.size + 30) {
            
            hitEnemy(enemy, getDamage('click'));
            hit = true;
            coreRecoil = 5; 
            break; 
        }
    }

    if (!hit) {
        // Miss visual
        floaters.push(new FloatingText(clickX, clickY, 'miss', '#555', 12));
    }
}

document.getElementById('prestige-btn').onclick = () => {
    if (confirm(`INITIATE SYSTEM REBOOT?\n\n- Resets Current Run\n- +25% Power per 5 Waves Cleared`)) {
        resetRun(true);
    }
};

function showModal(title, msg, btnText, action) {
    document.getElementById('modal-title').innerText = title;
    document.getElementById('modal-msg').innerText = msg;
    const btn = document.getElementById('modal-btn');
    btn.innerText = btnText;
    btn.onclick = action;
    document.getElementById('modal-overlay').style.display = 'flex';
}

requestAnimationFrame(gameLoop);
renderCards();

</script>
</body>
</html>
